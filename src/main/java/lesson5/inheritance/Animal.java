package main.java.lesson5.inheritance;

abstract class Animal { // 2-й вариант - чтобы не создавали экземпляры этого класса - abstract
    // По умолчанию обычно public class, но мы поставим abstract class Animal,
    // чтобы не создавали экземпляры этого класса.
    // Для абстрактных классов - можно реализовывать методы без реализации.
//////////////////
    // public abstract int age; Ошибка. Переменную нельзя делать абстрактной.

    private int age;
    private String name; // Перенесли из класса Cat, когда поняли, что будет много похожих классов,
    // и решили создать базовый класс Animal.
    //private int health; // lesson7_43:04 // перенесли в IAtackable.java 52:03
//////////////

    ///////////// Конструктор тоже переносим из класса Cat в базовый класс
    public Animal(String name) { // Поменяли название конструктора с Cat на Animal
        // Если сделать private Animal(String name), то в дочерних классах нельзя будет
        // достучаться до этого name, также нельзя будет создать экземпляр класса Animal.
        this.age = 50; // 50 по умолчанию, когда вызывается конструктор
        this.name = name;
        //this.health = 100; // lesson7_43:09, удалили 52:17
    }

    ////////////// Геттеры и сеттеры тоже перенесли из класса Cat в базовый класс, как и переменные.
    public String getName() { // публичный геттер
        return this.name + "!";  // return name; - тоже будет работать, компилятор его сам доставит
    }

    public void setName(String name) { // публичный сеттер
        this.name = name;
    }

    public String getName(String user) { // геттер, перегруженный - перегрузка метода
        return this.name + "! " + user;
    }
////////////////// Переопределяем метод toString()

    public String toString() { // toString() возвращает строку, этот метод переопределяет такой
        // же метод у Object
        return "My name is " + this.name + " and my age is " + this.age;
    }

    ////////////////// Переопределяем метод equals()
    public boolean equals(Animal obj) { // Методу будет скармливаться объект - конкретный экземпляр
        // класса Animal
        // return this.name == obj.name; // Мы хотим чтобы в случае совпадения имен у животных,
        // программа считала их равными. Отрабатывает нормально, но т.к. строка - это объект,
        // то лучше сравнивать через equals()
        return this.name.equals(obj.name); // У класса String есть свой метод equals()
        // У класса String метод equals работает более основательно, чем просто у Object,
        // он перебирает строку по каждому массиву смотрит.
    }


/////////////////
// Если сделать метод protected, то к этому методу смогут обращаться только классы, которые являются
// его наследниками. Если он не наследник и вне пакета, то не сможет обратиться сюда.
///////////////////

    // Можно реализовать методы без реализации для абстрактных классов:
    // Объявляем метод, который будет без реализации
    public abstract String greet();

    // Это значит, что любой класс, который наследуется от нашего класса должен либо
    // 1) быть сам абстрактным
    // 2) либо реализовать этот метод
    //............... lesson7_28:28
    // Абстрактный класс может обладать методами без реализации. Могут содержать как реализованные так и пустые методы.
    // Интерфейсы могут содержать только нереализованные методы. Интерфейсы не могут содержать реализацию внутри.
    //....................lesson7_42:13
/*    public void attack(Animal animal) { // Тут проблема, так как у всех животных будет снижаться здоровье при атаке.
        animal.health -= 10;
    }*/

    public void attack(IAtackable animal) {
        //animal.health -= 10; // подсвечивает красным health, исправлять пока не будем - нужны геттеры и сеттеры
        // Просто это для информации о том что с помощью интерфейсов можно ограничивать какие-то классы, которые не
        // должны сюда попадать
    }

}
