package main.java.lesson5.inheritance;

public class Dog extends Animal implements IAtackable { // lesson7_37:59 интерфейс, соответственно, если бы у
    // интерфейса был какой-то нереализованный метод, то мы были бы обязаны его здесь реализовать.
    public Dog(String name) { // Автоматически созданный конструктор с помощью варианта 2
        // System.out.println(""); // Обращение к super является обязательным в конструкторе, поэтому
        // при написании данной строки здесь, все загорается красным. В конструкторе мы не можем
        // вначале выполнить какую-то логику, а потом обратиться к родительскому классу
        super(name); // вариант 2 - смотри ниже
        //this.health = 100; // Подсвечивает красным lesson7_53:41, Нужно реализовывать геттеры и сеттеры.
    }
    // После написания extends Animal можно не 1-й вариант как у Cat - вбивание руками конструктора,а
    // 2-й вариант: нажать на красное выделение, которое подсвечивает надпись,
    // нажать на появившуюся красную лампочку и выбрать Create constructor matching super
    // Или же Alt+Enter
    // Автоматически создается конструктор
////////////////////

//////////  Полиморфизм. Переопределение методов в дочерних классах.
    // Частично или полностью переопределить.

    // Частичное переопределение метода:
// Допустим, метод getName у собаки (в отличие от кота) должен перед тем как вернуть имя еще вернуть
// в консоль приветственную фразу.
//    public String getName() {
//        System.out.println("Dog gives user its name:"); // Кроме того что в родительском геттере,
//        // хочу в консоль что-то распечатать
//        return super.getName(); // обращается к родительскому классу super и у этого родителя
//        // воспользоваться методом getName
//        // А в конструкторе обращение к super обязательно должно быть первым быть первым.
//    }

    // Полное переопределение метода:
    // Нам даже не нужно к родительскому классу обращаться
//    public String getName() {
//        System.out.println("Dog gives user its name:");
//        // return super.getName();
//        return "Overriden method name";
//    }
    // Полиморфные методы (методы, которые переопределяют) идея подсвечивает синим кружком
    // с красной стрелкой вверх.
    // Когда еще и есть перегрузки очень желательно добавлять аннотацию @Override, чтобы показать, что
    // метод является переопределенным, а не перегруженным.
    // Override говорит, что этот метод является именно переопределяющим
    // Если у родительского класса нет точно такого же метода, то Идея подсвечивает
    // Override красным, т.к нечего переопределять.
    // Если с такой же сигнатурой есть в родительском классе метод, то красным не подсвечивает
    @Override
    public String getName(String name) {
        System.out.println("Dog gives user its name:");
        // return super.getName();
        return "Overriden method name";
    }
    // Если сигнатуры в родительском и дочернем классах отличаются и не стоит Override
    // программа скомпилируется, будет работать, но тут не понятное объяснение преподавателя
    // Лучше всегда писать @Override, даже если подсвечивает красным, это убережет от ошибок в будущем.

    // Наследование абстрактных классво. Реализация методов от родительского абстрактного класса:
    @Override
    public String greet() { // Тут зеленый значок появляется с красной стрелочкой.
        //Можно, на всякий случай, поставить @Override.
        return "Hello, I am a Dog.";
    }

    @Override // Метод из интерфейса, который необходимо реализовать в классе:
    public int getHealth() {
        return 0;
    }
}
